#include <iostream>
#include <fstream>
#include "datalogger.h"

using namespace std;

int main(int argc, char** argv) {

    // Declare two DataLogger objects. One will be used to log all the incoming data.
    // The other will be a way of keeping track of "bad data".

    DataLogger data;
    DataLogger badSectorData; // a list of items with bad sectors

    // Check the command line args. When this program is run, it must be given a
    // filename for the data file. 
    
    if (argc != 2) {
	cout << "Usage: " << argv[0] << " <datafile>" << endl;
	exit(0);
    }

    // Declare some variables that we will use while reading in the data from
    // file.

    char* datafile = argv[1];
    ifstream inDatafile(datafile);
    int sector;
    int iron;
    int silicon;
    
    // Read the data from the datafile. We read one data parameter at a
    // time. Each set of three data parameters is considered a single "record"
    // and should be bundled together when stored in the data log.
    //
    // After we have read a complete record (three values) then we call the
    // "addData()" method on our DataLogger object. This means that the
    // DataLogger class must have a method called "addData()". This method
    // must accept the three data values. See the detailed description of
    // DataLogger in the instructions to know what you need to do with those
    // values.
    //
    // After adding the values to the data log, we check to see if any of the
    // values were "bad". Remember from the instructions that if we ever see
    // bad data in a sector then we assume that all data in that sector (past,
    // present, and future) is bad. In order to keep track of bad data, we use
    // a second DataLogger object. If the sector data is bad, we add that
    // sector to the bad data log.
    //
    // Finally, we check to see if the sector we're dealing with is in the bad
    // list. If it is then we make sure to remove that sector's data from the
    // good data log. Remember, all past data for a bad sector is discarded.

    while (!inDatafile.eof()) {
	inDatafile >> sector;
	inDatafile >> iron;
	inDatafile >> silicon;

	if (!inDatafile.eof()) {
	    data.addData(sector, iron, silicon);
	    if (((iron < 0) || (silicon < 0)) && !badSectorData.containsSector(sector)) {
		badSectorData.addData(sector,iron,silicon);
	    }

	    if (badSectorData.containsSector(sector)) {
		data.removeSector(sector);
	    }
	}
    }

    // After we've read all the data, we need to create a couple reports. The
    // first report is generated by calling DataLogger::printReport(). This
    // means that the DataLogger class needs to have a printReport()
    // method. See the instructions and output files for details of this
    // report.
    //
    // The second report is a list of bad sectors. This is done by calling the
    // "printSectorList()" method on the badSectorData object. Again, see the
    // instructions and output files for details of this output.

    data.printReport(); 

    cout << "----------------------------------------------------------------------" << endl;
    cout << "Bad sectors" << endl;
    cout << "----------------------------------------------------------------------" << endl;
    badSectorData.printSectorList();

    return(0);
}
